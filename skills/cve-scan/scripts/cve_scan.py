#!/usr/bin/env python3
"""
CVE Vulnerability Scanner
프로젝트 의존성 취약점 스캔 도구
"""

from __future__ import annotations

import argparse
import json
import os
import re
import subprocess
import sys
import urllib.request
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Literal

SEVERITY_ORDER = {"critical": 4, "high": 3, "medium": 2, "moderate": 2, "low": 1, "info": 0}


@dataclass
class Vulnerability:
    severity: str
    package: str
    version: str  # 설치된 버전
    vuln_range: str  # 취약 범위
    cve: str
    title: str
    stack: str
    fix_version: str = ""

    def severity_level(self) -> int:
        return SEVERITY_ORDER.get(self.severity.lower(), 0)


@dataclass
class ScanResult:
    stack: str
    vulnerabilities: list[Vulnerability] = field(default_factory=list)
    error: str = ""


def detect_stacks(path: Path) -> list[str]:
    """프로젝트 타입 감지"""
    stacks = []

    if (path / "package.json").exists():
        stacks.append("npm")
    if (path / "requirements.txt").exists() or (path / "pyproject.toml").exists():
        stacks.append("python")
    if (path / "pom.xml").exists():
        stacks.append("maven")
    if (path / "build.gradle").exists() or (path / "build.gradle.kts").exists():
        stacks.append("gradle")
    if (path / "composer.json").exists():
        stacks.append("php")

    return stacks


def _get_npm_installed_versions(path: Path) -> dict[str, str]:
    """package-lock.json에서 설치된 버전 가져오기"""
    lock_file = path / "package-lock.json"
    if not lock_file.exists():
        return {}

    try:
        with open(lock_file) as f:
            lock = json.load(f)

        versions = {}
        # lockfileVersion 2/3: packages 필드
        if "packages" in lock:
            for key, val in lock["packages"].items():
                if key.startswith("node_modules/"):
                    pkg_name = key.replace("node_modules/", "", 1)
                    # scoped package 처리 (@org/pkg)
                    versions[pkg_name] = val.get("version", "")
        # lockfileVersion 1: dependencies 필드
        elif "dependencies" in lock:
            for name, val in lock["dependencies"].items():
                versions[name] = val.get("version", "")

        return versions
    except Exception:
        return {}


def scan_npm(path: Path) -> ScanResult:
    """npm audit 실행"""
    result = ScanResult(stack="npm")

    try:
        # 설치된 버전 먼저 로드
        installed_versions = _get_npm_installed_versions(path)

        # npm audit --json
        proc = subprocess.run(
            ["npm", "audit", "--json"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=120,
        )

        if proc.returncode not in (0, 1):  # 1 = vulnerabilities found
            if "ELOCKNOENT" in proc.stderr or "package-lock.json" in proc.stderr:
                result.error = "package-lock.json not found. Run 'npm install' first."
                return result

        data = json.loads(proc.stdout) if proc.stdout else {}

        # npm audit v2/v3 format
        vulns = data.get("vulnerabilities", {})
        for pkg_name, info in vulns.items():
            severity = info.get("severity", "unknown")
            via = info.get("via", [])

            # 설치된 버전 가져오기
            installed_ver = installed_versions.get(pkg_name, "")
            vuln_range = info.get("range", "")

            # via가 dict면 직접 취약점, string이면 간접 의존성
            for v in via:
                if isinstance(v, dict):
                    result.vulnerabilities.append(Vulnerability(
                        severity=severity,
                        package=pkg_name,
                        version=installed_ver,  # 설치된 버전
                        vuln_range=vuln_range,  # 취약 범위
                        cve=v.get("url", "").split("/")[-1] if v.get("url") else "",
                        title=v.get("title", ""),
                        stack="npm",
                        fix_version=info.get("fixAvailable", {}).get("version", "") if isinstance(info.get("fixAvailable"), dict) else "",
                    ))
                    break  # 첫 번째 직접 취약점만

    except subprocess.TimeoutExpired:
        result.error = "npm audit timed out"
    except json.JSONDecodeError:
        result.error = "Failed to parse npm audit output"
    except FileNotFoundError:
        result.error = "npm not found. Install Node.js first."
    except Exception as e:
        result.error = str(e)

    return result


def scan_python(path: Path) -> ScanResult:
    """pip-audit 실행"""
    result = ScanResult(stack="python")

    # requirements.txt 또는 pyproject.toml 찾기
    req_file = None
    if (path / "requirements.txt").exists():
        req_file = path / "requirements.txt"

    try:
        cmd = ["pip-audit", "--format", "json"]
        if req_file:
            cmd.extend(["-r", str(req_file)])

        proc = subprocess.run(
            cmd,
            cwd=path,
            capture_output=True,
            text=True,
            timeout=120,
        )

        data = json.loads(proc.stdout) if proc.stdout else []

        for item in data:
            for vuln in item.get("vulns", []):
                # pip-audit는 severity를 직접 제공하지 않음, CVE로 추정
                result.vulnerabilities.append(Vulnerability(
                    severity="high",  # pip-audit는 severity 없음
                    package=item.get("name", ""),
                    version=item.get("version", ""),
                    vuln_range=vuln.get("affected_versions", ""),
                    cve=vuln.get("id", ""),
                    title=vuln.get("description", "")[:100],
                    stack="python",
                    fix_version=vuln.get("fix_versions", [""])[0] if vuln.get("fix_versions") else "",
                ))

    except subprocess.TimeoutExpired:
        result.error = "pip-audit timed out"
    except json.JSONDecodeError:
        result.error = "Failed to parse pip-audit output"
    except FileNotFoundError:
        result.error = "pip-audit not found. Install with: pip install pip-audit"
    except Exception as e:
        result.error = str(e)

    return result


def scan_php(path: Path) -> ScanResult:
    """composer audit 실행"""
    result = ScanResult(stack="php")

    try:
        proc = subprocess.run(
            ["composer", "audit", "--format", "json"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=120,
        )

        data = json.loads(proc.stdout) if proc.stdout else {}

        advisories = data.get("advisories", {})
        for pkg_name, vulns in advisories.items():
            for vuln in vulns:
                result.vulnerabilities.append(Vulnerability(
                    severity="high",
                    package=pkg_name,
                    version="",  # composer audit은 설치버전 별도 조회 필요
                    vuln_range=vuln.get("affectedVersions", ""),
                    cve=vuln.get("cve", ""),
                    title=vuln.get("title", ""),
                    stack="php",
                ))

    except subprocess.TimeoutExpired:
        result.error = "composer audit timed out"
    except json.JSONDecodeError:
        result.error = "Failed to parse composer audit output"
    except FileNotFoundError:
        result.error = "composer not found. Install Composer first."
    except Exception as e:
        result.error = str(e)

    return result


def scan_maven(path: Path) -> ScanResult:
    """Maven 의존성 스캔 (OWASP dependency-check 또는 기본 체크)"""
    result = ScanResult(stack="maven")

    try:
        # mvn dependency:tree로 의존성 확인
        proc = subprocess.run(
            ["mvn", "dependency:tree", "-DoutputType=text"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=300,
        )

        if proc.returncode != 0:
            result.error = "Maven build failed. Check pom.xml."
            return result

        # 기본적인 의존성 트리만 출력 (OWASP dependency-check 없으면)
        result.error = "Maven scan requires OWASP dependency-check plugin. Add to pom.xml or use 'mvn org.owasp:dependency-check-maven:check'"

    except subprocess.TimeoutExpired:
        result.error = "Maven scan timed out"
    except FileNotFoundError:
        result.error = "mvn not found. Install Maven first."
    except Exception as e:
        result.error = str(e)

    return result


def _parse_gradle_dependencies(output: str) -> list[tuple[str, str, str]]:
    """Gradle dependencies 출력에서 의존성 파싱

    Returns: list of (group_id, artifact_id, version)
    """
    dependencies = set()

    # 패턴: +--- group:artifact:version 또는 \--- group:artifact:version
    # 예: +--- org.springframework.boot:spring-boot-starter-web:3.2.0
    pattern = re.compile(r'[+\\]---\s+([^:]+):([^:]+):([^\s\(\)]+)')

    for line in output.split('\n'):
        match = pattern.search(line)
        if match:
            group_id, artifact_id, version = match.groups()
            # 버전이 없거나 변수인 경우 제외
            if version and not version.startswith('$') and not version.startswith('{'):
                # SNAPSHOT, ->, (*) 등 제외
                version = version.split(' ')[0].rstrip('*')
                if version and not version.endswith('SNAPSHOT'):
                    dependencies.add((group_id, artifact_id, version))

    return list(dependencies)


def _query_osv_maven(group_id: str, artifact_id: str, version: str) -> list[dict]:
    """OSV API로 Maven 패키지 취약점 조회"""
    url = "https://api.osv.dev/v1/query"

    # Maven 패키지 이름 형식: group_id:artifact_id
    package_name = f"{group_id}:{artifact_id}"

    payload = {
        "package": {
            "name": package_name,
            "ecosystem": "Maven"
        },
        "version": version
    }

    try:
        req = urllib.request.Request(
            url,
            data=json.dumps(payload).encode('utf-8'),
            headers={"Content-Type": "application/json"},
            method="POST"
        )

        with urllib.request.urlopen(req, timeout=10) as resp:
            data = json.loads(resp.read().decode('utf-8'))
            return data.get("vulns", [])
    except Exception:
        return []


def _osv_severity_to_level(vuln: dict) -> str:
    """OSV 취약점에서 severity 추출"""
    # severity 배열에서 CVSS 점수 확인
    for sev in vuln.get("severity", []):
        if sev.get("type") == "CVSS_V3":
            score_str = sev.get("score", "")
            # CVSS 벡터에서 점수 추출 시도
            try:
                # 직접 점수가 있는 경우
                if isinstance(score_str, (int, float)):
                    score = float(score_str)
                elif ":" in str(score_str):
                    # CVSS 벡터 문자열인 경우 database_specific에서 점수 확인
                    continue
                else:
                    score = float(score_str)

                if score >= 9.0:
                    return "critical"
                elif score >= 7.0:
                    return "high"
                elif score >= 4.0:
                    return "medium"
                else:
                    return "low"
            except (ValueError, TypeError):
                continue

    # database_specific에서 severity 확인
    db_specific = vuln.get("database_specific", {})
    if "severity" in db_specific:
        sev = db_specific["severity"].lower()
        if sev in ("critical", "high", "medium", "moderate", "low"):
            return "medium" if sev == "moderate" else sev

    # 기본값
    return "medium"


def _get_affected_range(vuln: dict) -> str:
    """OSV 취약점에서 영향받는 버전 범위 추출"""
    for affected in vuln.get("affected", []):
        ranges = affected.get("ranges", [])
        for r in ranges:
            events = r.get("events", [])
            introduced = None
            fixed = None
            for event in events:
                if "introduced" in event:
                    introduced = event["introduced"]
                if "fixed" in event:
                    fixed = event["fixed"]

            if introduced and fixed:
                return f">={introduced}, <{fixed}"
            elif introduced:
                return f">={introduced}"
            elif fixed:
                return f"<{fixed}"

        # versions 배열이 있는 경우
        versions = affected.get("versions", [])
        if versions:
            if len(versions) <= 3:
                return ", ".join(versions)
            else:
                return f"{versions[0]}...{versions[-1]}"

    return ""


def _get_fix_version(vuln: dict) -> str:
    """OSV 취약점에서 수정 버전 추출"""
    for affected in vuln.get("affected", []):
        ranges = affected.get("ranges", [])
        for r in ranges:
            events = r.get("events", [])
            for event in events:
                if "fixed" in event:
                    return event["fixed"]
    return ""


def scan_gradle(path: Path) -> ScanResult:
    """Gradle 의존성 스캔 (OSV API 연동)"""
    result = ScanResult(stack="gradle")

    try:
        gradle_cmd = "./gradlew" if (path / "gradlew").exists() else "gradle"

        print(f"[INFO] Running gradle dependencies...", file=sys.stderr)
        proc = subprocess.run(
            [gradle_cmd, "dependencies", "--console=plain", "-q"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=300,
        )

        if proc.returncode != 0:
            result.error = "Gradle build failed. Check build.gradle."
            return result

        # 의존성 파싱
        dependencies = _parse_gradle_dependencies(proc.stdout)

        if not dependencies:
            # 의존성이 없으면 성공으로 처리
            return result

        print(f"[INFO] Found {len(dependencies)} dependencies, querying OSV...", file=sys.stderr)

        # OSV API로 취약점 조회
        checked = 0
        for group_id, artifact_id, version in dependencies:
            vulns = _query_osv_maven(group_id, artifact_id, version)
            checked += 1

            for vuln in vulns:
                vuln_id = vuln.get("id", "")
                # CVE ID 우선, 없으면 GHSA 등 다른 ID
                cve_id = vuln_id
                for alias in vuln.get("aliases", []):
                    if alias.startswith("CVE-"):
                        cve_id = alias
                        break

                result.vulnerabilities.append(Vulnerability(
                    severity=_osv_severity_to_level(vuln),
                    package=f"{group_id}:{artifact_id}",
                    version=version,
                    vuln_range=_get_affected_range(vuln),
                    cve=cve_id,
                    title=vuln.get("summary", "")[:100],
                    stack="gradle",
                    fix_version=_get_fix_version(vuln),
                ))

        print(f"[INFO] Checked {checked} packages via OSV API", file=sys.stderr)

    except subprocess.TimeoutExpired:
        result.error = "Gradle scan timed out"
    except FileNotFoundError:
        result.error = "gradle/gradlew not found."
    except Exception as e:
        result.error = str(e)

    return result


def run_scan(path: Path, stacks: list[str] | None = None) -> list[ScanResult]:
    """스캔 실행"""
    if not stacks:
        stacks = detect_stacks(path)

    if not stacks:
        print(f"[WARN] No supported project files found in {path}", file=sys.stderr)
        return []

    results = []

    for stack in stacks:
        print(f"[INFO] Scanning {stack}...", file=sys.stderr)

        if stack == "npm":
            results.append(scan_npm(path))
        elif stack == "python":
            results.append(scan_python(path))
        elif stack == "php":
            results.append(scan_php(path))
        elif stack == "maven":
            results.append(scan_maven(path))
        elif stack == "gradle":
            results.append(scan_gradle(path))

    return results


def filter_by_severity(results: list[ScanResult], min_severity: str) -> list[ScanResult]:
    """심각도 필터링"""
    min_level = SEVERITY_ORDER.get(min_severity.lower(), 0)

    for result in results:
        result.vulnerabilities = [
            v for v in result.vulnerabilities
            if v.severity_level() >= min_level
        ]

    return results


def print_table(results: list[ScanResult]) -> None:
    """테이블 형식 출력"""
    print(f"\n{'='*60}")
    print(f"CVE Scan Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*60}\n")

    total_vulns = 0
    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}

    for result in results:
        if result.error:
            print(f"[{result.stack.upper()}] Error: {result.error}\n")
            continue

        vulns = result.vulnerabilities
        total_vulns += len(vulns)

        if not vulns:
            print(f"[{result.stack.upper()}] No vulnerabilities found\n")
            continue

        print(f"[{result.stack.upper()}] {len(vulns)} vulnerabilities found")
        print("-" * 100)
        print(f"{'Severity':<10} {'Package':<20} {'Installed':<12} {'Vuln Range':<20} {'Fix':<10}")
        print("-" * 100)

        for v in sorted(vulns, key=lambda x: -x.severity_level()):
            sev = v.severity.upper()
            severity_counts[v.severity.lower()] = severity_counts.get(v.severity.lower(), 0) + 1
            pkg = v.package[:19]
            ver = v.version[:11] if v.version else "N/A"
            vuln_range = v.vuln_range[:19] if v.vuln_range else "N/A"
            fix = v.fix_version[:9] if v.fix_version else "-"
            print(f"{sev:<10} {pkg:<20} {ver:<12} {vuln_range:<20} {fix:<10}")

        print()

    # Summary
    print("=" * 60)
    print(f"Total: {total_vulns} vulnerabilities", end="")
    if total_vulns > 0:
        parts = []
        for sev in ["critical", "high", "medium", "low"]:
            if severity_counts.get(sev, 0) > 0:
                parts.append(f"{severity_counts[sev]} {sev}")
        print(f" ({', '.join(parts)})")
    else:
        print()


def print_json(results: list[ScanResult]) -> str:
    """JSON 형식 출력"""
    output = {
        "timestamp": datetime.now().isoformat(),
        "results": []
    }

    for result in results:
        output["results"].append({
            "stack": result.stack,
            "error": result.error,
            "vulnerabilities": [
                {
                    "severity": v.severity,
                    "package": v.package,
                    "installed_version": v.version,
                    "vuln_range": v.vuln_range,
                    "cve": v.cve,
                    "title": v.title,
                    "fix_version": v.fix_version,
                }
                for v in result.vulnerabilities
            ]
        })

    return json.dumps(output, indent=2, ensure_ascii=False)


def print_markdown(results: list[ScanResult], path: str = "") -> str:
    """Markdown 형식 출력"""
    lines = []
    lines.append(f"# CVE Scan Report")
    lines.append(f"")
    lines.append(f"> Scanned: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    if path:
        lines.append(f"> Path: `{path}`")
    lines.append(f"")

    total_vulns = 0
    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}

    for result in results:
        lines.append(f"## {result.stack.upper()}")
        lines.append(f"")

        if result.error:
            lines.append(f"**Error:** {result.error}")
            lines.append(f"")
            continue

        vulns = result.vulnerabilities
        total_vulns += len(vulns)

        if not vulns:
            lines.append(f"No vulnerabilities found.")
            lines.append(f"")
            continue

        lines.append(f"**{len(vulns)} vulnerabilities found**")
        lines.append(f"")
        lines.append(f"| Severity | Package | Installed | Vuln Range | Fix |")
        lines.append(f"|----------|---------|-----------|------------|-----|")

        for v in sorted(vulns, key=lambda x: -x.severity_level()):
            sev = v.severity.upper()
            severity_counts[v.severity.lower()] = severity_counts.get(v.severity.lower(), 0) + 1
            pkg = v.package
            ver = v.version if v.version else "N/A"
            vuln_range = v.vuln_range if v.vuln_range else "N/A"
            fix = v.fix_version if v.fix_version else "-"
            cve_link = f"[{v.cve}](https://github.com/advisories/{v.cve})" if v.cve.startswith("GHSA") else v.cve
            lines.append(f"| **{sev}** | {pkg} | {ver} | {vuln_range} | {fix} |")

        lines.append(f"")

    # Summary
    lines.append(f"---")
    lines.append(f"")
    lines.append(f"## Summary")
    lines.append(f"")
    if total_vulns > 0:
        lines.append(f"| Severity | Count |")
        lines.append(f"|----------|-------|")
        for sev in ["critical", "high", "medium", "low"]:
            if severity_counts.get(sev, 0) > 0:
                lines.append(f"| {sev.upper()} | {severity_counts[sev]} |")
        lines.append(f"| **Total** | **{total_vulns}** |")
    else:
        lines.append(f"No vulnerabilities found.")

    return "\n".join(lines)


def cmd_scan(args: argparse.Namespace) -> None:
    """scan 명령어"""
    path = Path(args.path).resolve()

    if not path.exists():
        print(f"[ERROR] Path not found: {path}", file=sys.stderr)
        sys.exit(1)

    stacks = [args.stack] if args.stack else None
    results = run_scan(path, stacks)

    if args.severity:
        results = filter_by_severity(results, args.severity)

    if args.format == "json":
        output = print_json(results)
        if args.output:
            Path(args.output).write_text(output)
            print(f"[INFO] Report saved to {args.output}", file=sys.stderr)
        else:
            print(output)
    elif args.format == "md" or args.format == "markdown":
        output = print_markdown(results, str(path))
        if args.output:
            Path(args.output).write_text(output)
            print(f"[INFO] Report saved to {args.output}", file=sys.stderr)
        else:
            print(output)
    else:
        print_table(results)
        if args.output:
            # 테이블도 파일로 저장
            import io
            from contextlib import redirect_stdout
            f = io.StringIO()
            with redirect_stdout(f):
                print_table(results)
            Path(args.output).write_text(f.getvalue())
            print(f"[INFO] Report saved to {args.output}", file=sys.stderr)


def cmd_detect(args: argparse.Namespace) -> None:
    """detect 명령어"""
    path = Path(args.path).resolve()

    if not path.exists():
        print(f"[ERROR] Path not found: {path}", file=sys.stderr)
        sys.exit(1)

    stacks = detect_stacks(path)

    if not stacks:
        print("No supported project types detected.")
    else:
        print(f"Detected stacks: {', '.join(stacks)}")
        for stack in stacks:
            if stack == "npm":
                print(f"  - npm: package.json found")
            elif stack == "python":
                print(f"  - python: requirements.txt or pyproject.toml found")
            elif stack == "maven":
                print(f"  - maven: pom.xml found")
            elif stack == "gradle":
                print(f"  - gradle: build.gradle found")
            elif stack == "php":
                print(f"  - php: composer.json found")


def main() -> None:
    parser = argparse.ArgumentParser(description="CVE Vulnerability Scanner")
    subparsers = parser.add_subparsers(dest="command", help="명령어")

    # scan
    scan_parser = subparsers.add_parser("scan", help="취약점 스캔 실행")
    scan_parser.add_argument("--path", default=".", help="스캔할 프로젝트 경로")
    scan_parser.add_argument("--stack", choices=["npm", "python", "maven", "gradle", "php"], help="특정 스택만 스캔")
    scan_parser.add_argument("--severity", choices=["low", "medium", "high", "critical"], help="최소 심각도 필터")
    scan_parser.add_argument("--format", choices=["table", "json", "md", "markdown"], default="table", help="출력 형식")
    scan_parser.add_argument("--output", help="결과 저장 파일")
    scan_parser.add_argument("--fix", action="store_true", help="자동 수정 시도")
    scan_parser.set_defaults(func=cmd_scan)

    # detect
    detect_parser = subparsers.add_parser("detect", help="프로젝트 타입 감지")
    detect_parser.add_argument("--path", default=".", help="프로젝트 경로")
    detect_parser.set_defaults(func=cmd_detect)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == "__main__":
    main()
