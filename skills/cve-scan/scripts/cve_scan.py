#!/usr/bin/env python3
"""
CVE Vulnerability Scanner
프로젝트 의존성 취약점 스캔 도구
"""

from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Literal

SEVERITY_ORDER = {"critical": 4, "high": 3, "medium": 2, "moderate": 2, "low": 1, "info": 0}


@dataclass
class Vulnerability:
    severity: str
    package: str
    version: str  # 설치된 버전
    vuln_range: str  # 취약 범위
    cve: str
    title: str
    stack: str
    fix_version: str = ""

    def severity_level(self) -> int:
        return SEVERITY_ORDER.get(self.severity.lower(), 0)


@dataclass
class ScanResult:
    stack: str
    vulnerabilities: list[Vulnerability] = field(default_factory=list)
    error: str = ""


def detect_stacks(path: Path) -> list[str]:
    """프로젝트 타입 감지"""
    stacks = []

    if (path / "package.json").exists():
        stacks.append("npm")
    if (path / "requirements.txt").exists() or (path / "pyproject.toml").exists():
        stacks.append("python")
    if (path / "pom.xml").exists():
        stacks.append("maven")
    if (path / "build.gradle").exists() or (path / "build.gradle.kts").exists():
        stacks.append("gradle")
    if (path / "composer.json").exists():
        stacks.append("php")

    return stacks


def _get_npm_installed_versions(path: Path) -> dict[str, str]:
    """package-lock.json에서 설치된 버전 가져오기"""
    lock_file = path / "package-lock.json"
    if not lock_file.exists():
        return {}

    try:
        with open(lock_file) as f:
            lock = json.load(f)

        versions = {}
        # lockfileVersion 2/3: packages 필드
        if "packages" in lock:
            for key, val in lock["packages"].items():
                if key.startswith("node_modules/"):
                    pkg_name = key.replace("node_modules/", "", 1)
                    # scoped package 처리 (@org/pkg)
                    versions[pkg_name] = val.get("version", "")
        # lockfileVersion 1: dependencies 필드
        elif "dependencies" in lock:
            for name, val in lock["dependencies"].items():
                versions[name] = val.get("version", "")

        return versions
    except Exception:
        return {}


def scan_npm(path: Path) -> ScanResult:
    """npm audit 실행"""
    result = ScanResult(stack="npm")

    try:
        # 설치된 버전 먼저 로드
        installed_versions = _get_npm_installed_versions(path)

        # npm audit --json
        proc = subprocess.run(
            ["npm", "audit", "--json"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=120,
        )

        if proc.returncode not in (0, 1):  # 1 = vulnerabilities found
            if "ELOCKNOENT" in proc.stderr or "package-lock.json" in proc.stderr:
                result.error = "package-lock.json not found. Run 'npm install' first."
                return result

        data = json.loads(proc.stdout) if proc.stdout else {}

        # npm audit v2/v3 format
        vulns = data.get("vulnerabilities", {})
        for pkg_name, info in vulns.items():
            severity = info.get("severity", "unknown")
            via = info.get("via", [])

            # 설치된 버전 가져오기
            installed_ver = installed_versions.get(pkg_name, "")
            vuln_range = info.get("range", "")

            # via가 dict면 직접 취약점, string이면 간접 의존성
            for v in via:
                if isinstance(v, dict):
                    result.vulnerabilities.append(Vulnerability(
                        severity=severity,
                        package=pkg_name,
                        version=installed_ver,  # 설치된 버전
                        vuln_range=vuln_range,  # 취약 범위
                        cve=v.get("url", "").split("/")[-1] if v.get("url") else "",
                        title=v.get("title", ""),
                        stack="npm",
                        fix_version=info.get("fixAvailable", {}).get("version", "") if isinstance(info.get("fixAvailable"), dict) else "",
                    ))
                    break  # 첫 번째 직접 취약점만

    except subprocess.TimeoutExpired:
        result.error = "npm audit timed out"
    except json.JSONDecodeError:
        result.error = "Failed to parse npm audit output"
    except FileNotFoundError:
        result.error = "npm not found. Install Node.js first."
    except Exception as e:
        result.error = str(e)

    return result


def scan_python(path: Path) -> ScanResult:
    """pip-audit 실행"""
    result = ScanResult(stack="python")

    # requirements.txt 또는 pyproject.toml 찾기
    req_file = None
    if (path / "requirements.txt").exists():
        req_file = path / "requirements.txt"

    try:
        cmd = ["pip-audit", "--format", "json"]
        if req_file:
            cmd.extend(["-r", str(req_file)])

        proc = subprocess.run(
            cmd,
            cwd=path,
            capture_output=True,
            text=True,
            timeout=120,
        )

        data = json.loads(proc.stdout) if proc.stdout else []

        for item in data:
            for vuln in item.get("vulns", []):
                # pip-audit는 severity를 직접 제공하지 않음, CVE로 추정
                result.vulnerabilities.append(Vulnerability(
                    severity="high",  # pip-audit는 severity 없음
                    package=item.get("name", ""),
                    version=item.get("version", ""),
                    vuln_range=vuln.get("affected_versions", ""),
                    cve=vuln.get("id", ""),
                    title=vuln.get("description", "")[:100],
                    stack="python",
                    fix_version=vuln.get("fix_versions", [""])[0] if vuln.get("fix_versions") else "",
                ))

    except subprocess.TimeoutExpired:
        result.error = "pip-audit timed out"
    except json.JSONDecodeError:
        result.error = "Failed to parse pip-audit output"
    except FileNotFoundError:
        result.error = "pip-audit not found. Install with: pip install pip-audit"
    except Exception as e:
        result.error = str(e)

    return result


def scan_php(path: Path) -> ScanResult:
    """composer audit 실행"""
    result = ScanResult(stack="php")

    try:
        proc = subprocess.run(
            ["composer", "audit", "--format", "json"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=120,
        )

        data = json.loads(proc.stdout) if proc.stdout else {}

        advisories = data.get("advisories", {})
        for pkg_name, vulns in advisories.items():
            for vuln in vulns:
                result.vulnerabilities.append(Vulnerability(
                    severity="high",
                    package=pkg_name,
                    version="",  # composer audit은 설치버전 별도 조회 필요
                    vuln_range=vuln.get("affectedVersions", ""),
                    cve=vuln.get("cve", ""),
                    title=vuln.get("title", ""),
                    stack="php",
                ))

    except subprocess.TimeoutExpired:
        result.error = "composer audit timed out"
    except json.JSONDecodeError:
        result.error = "Failed to parse composer audit output"
    except FileNotFoundError:
        result.error = "composer not found. Install Composer first."
    except Exception as e:
        result.error = str(e)

    return result


def scan_maven(path: Path) -> ScanResult:
    """Maven 의존성 스캔 (OWASP dependency-check 또는 기본 체크)"""
    result = ScanResult(stack="maven")

    try:
        # mvn dependency:tree로 의존성 확인
        proc = subprocess.run(
            ["mvn", "dependency:tree", "-DoutputType=text"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=300,
        )

        if proc.returncode != 0:
            result.error = "Maven build failed. Check pom.xml."
            return result

        # 기본적인 의존성 트리만 출력 (OWASP dependency-check 없으면)
        result.error = "Maven scan requires OWASP dependency-check plugin. Add to pom.xml or use 'mvn org.owasp:dependency-check-maven:check'"

    except subprocess.TimeoutExpired:
        result.error = "Maven scan timed out"
    except FileNotFoundError:
        result.error = "mvn not found. Install Maven first."
    except Exception as e:
        result.error = str(e)

    return result


def scan_gradle(path: Path) -> ScanResult:
    """Gradle 의존성 스캔"""
    result = ScanResult(stack="gradle")

    try:
        gradle_cmd = "./gradlew" if (path / "gradlew").exists() else "gradle"

        proc = subprocess.run(
            [gradle_cmd, "dependencies", "--console=plain"],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=300,
        )

        if proc.returncode != 0:
            result.error = "Gradle build failed. Check build.gradle."
            return result

        result.error = "Gradle scan requires dependency-check plugin. Add 'org.owasp.dependencycheck' plugin to build.gradle."

    except subprocess.TimeoutExpired:
        result.error = "Gradle scan timed out"
    except FileNotFoundError:
        result.error = "gradle/gradlew not found."
    except Exception as e:
        result.error = str(e)

    return result


def run_scan(path: Path, stacks: list[str] | None = None) -> list[ScanResult]:
    """스캔 실행"""
    if not stacks:
        stacks = detect_stacks(path)

    if not stacks:
        print(f"[WARN] No supported project files found in {path}", file=sys.stderr)
        return []

    results = []

    for stack in stacks:
        print(f"[INFO] Scanning {stack}...", file=sys.stderr)

        if stack == "npm":
            results.append(scan_npm(path))
        elif stack == "python":
            results.append(scan_python(path))
        elif stack == "php":
            results.append(scan_php(path))
        elif stack == "maven":
            results.append(scan_maven(path))
        elif stack == "gradle":
            results.append(scan_gradle(path))

    return results


def filter_by_severity(results: list[ScanResult], min_severity: str) -> list[ScanResult]:
    """심각도 필터링"""
    min_level = SEVERITY_ORDER.get(min_severity.lower(), 0)

    for result in results:
        result.vulnerabilities = [
            v for v in result.vulnerabilities
            if v.severity_level() >= min_level
        ]

    return results


def print_table(results: list[ScanResult]) -> None:
    """테이블 형식 출력"""
    print(f"\n{'='*60}")
    print(f"CVE Scan Report - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"{'='*60}\n")

    total_vulns = 0
    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0}

    for result in results:
        if result.error:
            print(f"[{result.stack.upper()}] Error: {result.error}\n")
            continue

        vulns = result.vulnerabilities
        total_vulns += len(vulns)

        if not vulns:
            print(f"[{result.stack.upper()}] No vulnerabilities found\n")
            continue

        print(f"[{result.stack.upper()}] {len(vulns)} vulnerabilities found")
        print("-" * 100)
        print(f"{'Severity':<10} {'Package':<20} {'Installed':<12} {'Vuln Range':<20} {'Fix':<10}")
        print("-" * 100)

        for v in sorted(vulns, key=lambda x: -x.severity_level()):
            sev = v.severity.upper()
            severity_counts[v.severity.lower()] = severity_counts.get(v.severity.lower(), 0) + 1
            pkg = v.package[:19]
            ver = v.version[:11] if v.version else "N/A"
            vuln_range = v.vuln_range[:19] if v.vuln_range else "N/A"
            fix = v.fix_version[:9] if v.fix_version else "-"
            print(f"{sev:<10} {pkg:<20} {ver:<12} {vuln_range:<20} {fix:<10}")

        print()

    # Summary
    print("=" * 60)
    print(f"Total: {total_vulns} vulnerabilities", end="")
    if total_vulns > 0:
        parts = []
        for sev in ["critical", "high", "medium", "low"]:
            if severity_counts.get(sev, 0) > 0:
                parts.append(f"{severity_counts[sev]} {sev}")
        print(f" ({', '.join(parts)})")
    else:
        print()


def print_json(results: list[ScanResult]) -> str:
    """JSON 형식 출력"""
    output = {
        "timestamp": datetime.now().isoformat(),
        "results": []
    }

    for result in results:
        output["results"].append({
            "stack": result.stack,
            "error": result.error,
            "vulnerabilities": [
                {
                    "severity": v.severity,
                    "package": v.package,
                    "installed_version": v.version,
                    "vuln_range": v.vuln_range,
                    "cve": v.cve,
                    "title": v.title,
                    "fix_version": v.fix_version,
                }
                for v in result.vulnerabilities
            ]
        })

    return json.dumps(output, indent=2, ensure_ascii=False)


def cmd_scan(args: argparse.Namespace) -> None:
    """scan 명령어"""
    path = Path(args.path).resolve()

    if not path.exists():
        print(f"[ERROR] Path not found: {path}", file=sys.stderr)
        sys.exit(1)

    stacks = [args.stack] if args.stack else None
    results = run_scan(path, stacks)

    if args.severity:
        results = filter_by_severity(results, args.severity)

    if args.format == "json":
        output = print_json(results)
        if args.output:
            Path(args.output).write_text(output)
            print(f"[INFO] Report saved to {args.output}", file=sys.stderr)
        else:
            print(output)
    else:
        print_table(results)
        if args.output:
            # 테이블도 파일로 저장
            import io
            from contextlib import redirect_stdout
            f = io.StringIO()
            with redirect_stdout(f):
                print_table(results)
            Path(args.output).write_text(f.getvalue())
            print(f"[INFO] Report saved to {args.output}", file=sys.stderr)


def cmd_detect(args: argparse.Namespace) -> None:
    """detect 명령어"""
    path = Path(args.path).resolve()

    if not path.exists():
        print(f"[ERROR] Path not found: {path}", file=sys.stderr)
        sys.exit(1)

    stacks = detect_stacks(path)

    if not stacks:
        print("No supported project types detected.")
    else:
        print(f"Detected stacks: {', '.join(stacks)}")
        for stack in stacks:
            if stack == "npm":
                print(f"  - npm: package.json found")
            elif stack == "python":
                print(f"  - python: requirements.txt or pyproject.toml found")
            elif stack == "maven":
                print(f"  - maven: pom.xml found")
            elif stack == "gradle":
                print(f"  - gradle: build.gradle found")
            elif stack == "php":
                print(f"  - php: composer.json found")


def main() -> None:
    parser = argparse.ArgumentParser(description="CVE Vulnerability Scanner")
    subparsers = parser.add_subparsers(dest="command", help="명령어")

    # scan
    scan_parser = subparsers.add_parser("scan", help="취약점 스캔 실행")
    scan_parser.add_argument("--path", default=".", help="스캔할 프로젝트 경로")
    scan_parser.add_argument("--stack", choices=["npm", "python", "maven", "gradle", "php"], help="특정 스택만 스캔")
    scan_parser.add_argument("--severity", choices=["low", "medium", "high", "critical"], help="최소 심각도 필터")
    scan_parser.add_argument("--format", choices=["table", "json"], default="table", help="출력 형식")
    scan_parser.add_argument("--output", help="결과 저장 파일")
    scan_parser.add_argument("--fix", action="store_true", help="자동 수정 시도")
    scan_parser.set_defaults(func=cmd_scan)

    # detect
    detect_parser = subparsers.add_parser("detect", help="프로젝트 타입 감지")
    detect_parser.add_argument("--path", default=".", help="프로젝트 경로")
    detect_parser.set_defaults(func=cmd_detect)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    args.func(args)


if __name__ == "__main__":
    main()
